# Reusable Workflow: Create Deploy Issue on Direct Push
# Called by individual repos when someone pushes directly to main without a PR.
# Creates a tracking issue and adds it to the org project board with "Ready for Deployment" status.

name: Create Deploy Issue on Direct Push

on:
  workflow_call:
    inputs:
      deploy-commands:
        description: "Repo-specific deploy commands to include in the issue body"
        required: true
        type: string
    secrets:
      PROJECT_PAT:
        description: "PAT with project write access for Projects v2 mutations"
        required: true

jobs:
  create-deploy-issue:
    runs-on: ubuntu-latest
    permissions:
      issues: write
      contents: read
      pull-requests: read
    steps:
      - name: Check for direct push and create issue
        uses: actions/github-script@v7
        env:
          DEPLOY_COMMANDS: ${{ inputs.deploy-commands }}
          PROJECT_PAT: ${{ secrets.PROJECT_PAT }}
        with:
          # Use default GITHUB_TOKEN for repo operations (issues, commits, PRs)
          script: |
            const headCommit = context.payload.head_commit;
            if (!headCommit) {
              core.info('No head commit found, skipping.');
              return;
            }

            // Check if this commit is associated with a merged PR
            const { data: prs } = await github.rest.repos.listPullRequestsAssociatedWithCommit({
              owner: context.repo.owner,
              repo: context.repo.repo,
              commit_sha: headCommit.id,
            });

            const mergedPR = prs.find(pr => pr.merged_at !== null);
            if (mergedPR) {
              core.info(`Commit associated with merged PR #${mergedPR.number}, skipping.`);
              return;
            }

            // =================================================================
            // HELPER: Add an issue to the org project with "Ready for Deployment" status
            // Uses PROJECT_PAT (separate from GITHUB_TOKEN) for org project access
            // =================================================================
            async function graphqlWithPAT(query, variables = {}) {
              const response = await fetch('https://api.github.com/graphql', {
                method: 'POST',
                headers: {
                  'Authorization': `bearer ${process.env.PROJECT_PAT}`,
                  'Content-Type': 'application/json',
                },
                body: JSON.stringify({ query, variables }),
              });
              const result = await response.json();
              if (result.errors) {
                throw new Error(result.errors.map(e => e.message).join(', '));
              }
              return result.data;
            }

            async function addToProjectWithDeploymentStatus(issueNodeId) {
              const projectQuery = `query($org: String!, $number: Int!) {
                organization(login: $org) {
                  projectV2(number: $number) {
                    id
                    field(name: "Status") {
                      ... on ProjectV2SingleSelectField {
                        id
                        options {
                          id
                          name
                        }
                      }
                    }
                  }
                }
              }`;

              const projectData = await graphqlWithPAT(projectQuery, {
                org: 'myfplminileague',
                number: 1,
              });

              const projectId = projectData.organization.projectV2.id;
              const statusField = projectData.organization.projectV2.field;
              const deploymentOption = statusField.options.find(
                (opt) => opt.name === 'Ready for Deployment',
              );

              if (!deploymentOption) {
                core.error(
                  'Could not find "Ready for Deployment" status option in project. Available: ' +
                    statusField.options.map((o) => o.name).join(', '),
                );
                return;
              }

              const addItemMutation = `mutation($projectId: ID!, $contentId: ID!) {
                addProjectV2ItemById(input: {
                  projectId: $projectId
                  contentId: $contentId
                }) {
                  item { id }
                }
              }`;

              const addResult = await graphqlWithPAT(addItemMutation, {
                projectId,
                contentId: issueNodeId,
              });

              const itemId = addResult.addProjectV2ItemById.item.id;

              const updateStatusMutation = `mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $optionId: String!) {
                updateProjectV2ItemFieldValue(input: {
                  projectId: $projectId
                  itemId: $itemId
                  fieldId: $fieldId
                  value: { singleSelectOptionId: $optionId }
                }) {
                  projectV2Item { id }
                }
              }`;

              await graphqlWithPAT(updateStatusMutation, {
                projectId,
                itemId,
                fieldId: statusField.id,
                optionId: deploymentOption.id,
              });

              core.info('Added issue to project with "Ready for Deployment" status');
            }

            // =================================================================
            // Gather commit info
            // =================================================================
            const commits = context.payload.commits || [];
            const commitRows = commits.map(c => {
              const shortSha = c.id.substring(0, 7);
              const msg = c.message.split('\n')[0];
              const author = c.author.username || c.author.name;
              return `| \`${shortSha}\` | ${msg} | @${author} |`;
            }).join('\n');

            // Get all files changed across pushed commits
            let files = '_Unable to determine changed files_';
            const before = context.payload.before;
            const after = context.payload.after;

            if (before && !/^0+$/.test(before)) {
              try {
                const { data: comparison } = await github.rest.repos.compareCommits({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  base: before,
                  head: after,
                });
                files = (comparison.files || []).map(f => `- \`${f.filename}\` (${f.status})`).join('\n');
              } catch (e) {
                core.warning(`Failed to compare commits: ${e.message}`);
              }
            }

            if (files === '_Unable to determine changed files_') {
              try {
                const { data: commitDetail } = await github.rest.repos.getCommit({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: headCommit.id,
                });
                files = (commitDetail.files || []).map(f => `- \`${f.filename}\` (${f.status})`).join('\n');
              } catch (e) {
                core.warning(`Failed to get commit details: ${e.message}`);
              }
            }

            // =================================================================
            // Create the deploy tracking issue
            // =================================================================
            const pusher = context.actor;
            const summary = headCommit.message.split('\n')[0];
            const now = new Date().toISOString().replace('T', ' ').substring(0, 19);
            const deployCommands = process.env.DEPLOY_COMMANDS;

            const body = [
              '## Direct Push to `main` â€” Ready for Deployment',
              '',
              `**Pushed by**: @${pusher}`,
              `**Repo**: \`${context.repo.owner}/${context.repo.repo}\``,
              `**Date**: ${now} UTC`,
              '',
              '### Commits',
              '',
              '| SHA | Message | Author |',
              '|-----|---------|--------|',
              commitRows,
              '',
              '### Files Changed',
              '',
              files || '_No file details available_',
              '',
              '### Deploy Commands',
              '',
              '```bash',
              deployCommands,
              '```',
              '',
              '---',
              '> This issue was auto-created because changes were pushed directly to `main` without a PR.',
              '> Move to "Done" on the project board after deploying.',
            ].join('\n');

            const newIssue = await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `Deploy: ${summary} (direct push by @${pusher})`,
              body,
            });

            core.info(`Created deploy issue #${newIssue.data.number}`);

            // Add to project with "Deployment" status
            await addToProjectWithDeploymentStatus(newIssue.data.node_id);

            core.info(`Deploy issue #${newIssue.data.number} added to project with Ready for Deployment status`);
